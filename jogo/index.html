<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Glyphcaster's Last Stand</title>
    <style>
        :root {
            --background-color: #0d0d12;
            --glyph-primary: #FFFFFF;
            --glyph-danger: #FF0000;
            --ui-accent: #D4AF37;
            --ui-accent-glow: rgba(212, 175, 55, 0.7);
            --ui-text: #EAEAEA;
            --damage-text-crit: #FF4500;
            --particle-1: #FF00FF;
            --particle-2: #FFFF00;
            --particle-3: #FF4500;
            --particle-4: #F08080;
            --background-translucent: rgba(13, 13, 18, 0.92);
            --rarity-common: #FFFFFF;
            --rarity-uncommon: #1eff00;
            --rarity-epic: #9c27b0;
            --rarity-ascension: #ffc107;
        }

        @keyframes background-pan {
            0% { background-position: 0% 0%; }
            100% { background-position: 100% 100%; }
        }
        
        @keyframes title-glow {
            0% { text-shadow: 0 0 15px var(--ui-accent-glow), 0 0 30px var(--ui-accent-glow); }
            50% { text-shadow: 0 0 20px var(--ui-accent-glow), 0 0 40px var(--ui-accent-glow); }
            100% { text-shadow: 0 0 15px var(--ui-accent-glow), 0 0 30px var(--ui-accent-glow); }
        }

        @keyframes wave-announce-anim {
            0% { transform: scale(0.8) translateY(-50%); opacity: 0; }
            20% { transform: scale(1.1) translateY(-50%); opacity: 1; }
            80% { transform: scale(1) translateY(-50%); opacity: 1; }
            100% { transform: scale(0.8) translateY(-50%); opacity: 0; }
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            color: var(--ui-text);
            font-family: 'Consolas', 'Courier New', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }

        #game-container {
            position: relative;
            width: 1366px;
            height: 768px;
            box-shadow: 0 0 30px rgba(212, 175, 55, 0.2);
            /* --- MODIFICADO: Agora usa .png --- */
            background-image: url('castle-background.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            overflow: hidden;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            z-index: 2;
        }
        
        #ground-image {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100px; 
            /* --- MODIFICADO: Agora usa .png --- */
            background-image: url('ground.png');
            background-size: cover;
            background-position: center bottom;
            background-repeat: repeat-x;
            z-index: 1;
        }

        #player-sprite {
            position: absolute;
            width: 50px;
            height: 80px;
            /* --- MODIFICADO: Agora usa .png --- */
            background-image: url('archer.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            transform: translate(-50%, -50%);
            transition: transform 0.1s;
            z-index: 3;
        }

        #player-sprite.flipped {
            transform: translate(-50%, -50%) scaleX(-1);
        }

        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            z-index: 4;
        }

        .hud-row{display:flex;justify-content:space-between;padding:15px 20px;align-items:flex-start}#hud-top-left,#hud-top-right,#hud-bottom-left{display:flex;align-items:center;gap:15px}#hud-top-right{justify-content:flex-end;flex-direction:column;align-items:flex-end;gap:5px}#hud-top-center{position:absolute;left:50%;transform:translateX(-50%);display:flex;flex-direction:column;align-items:center;top:0;background-color:rgba(0,0,0,.3);padding:8px 30px 15px;clip-path:polygon(0 0,100% 0,95% 100%,5% 100%)}#xp-bar-container{width:300px;height:8px;background-color:rgba(212,175,55,.15);margin-top:8px;clip-path:polygon(0 0,100% 0,99% 100%,1% 100%);border:1px solid var(--ui-accent-glow);box-sizing:border-box}#xp-bar{width:0;height:100%;background:linear-gradient(90deg,#d4af37,#ffdf80);transition:width .3s ease-in-out;box-shadow:0 0 8px var(--ui-accent-glow)}#hp-bar-container{width:220px;height:20px;background-color:#333;clip-path:polygon(0 0,95% 0,100% 50%,95% 100%,0 100%);padding:2px}#hp-bar{width:100%;height:100%;background:linear-gradient(90deg,red,#dc143c);transition:width .2s ease-out;clip-path:polygon(0 0,95% 0,100% 50%,95% 100%,0 100%);box-shadow:inset 0 0 5px rgba(0,0,0,.5)}#hp-text,#souls-text,#kills-text,#timer-text,#total-souls-text{font-size:1.2em;text-shadow:1px 1px 3px #000}#level-text,#wave-text{font-size:1.1em;color:var(--ui-accent);text-shadow:1px 1px 2px #000,0 0 5px var(--ui-accent-glow)}.upgrade-tray{display:flex;gap:10px;padding:15px 20px;background-color:rgba(0,0,0,.3);border-top:1px solid var(--ui-accent-glow);border-right:1px solid var(--ui-accent-glow);border-top-right-radius:15px}.upgrade-icon{width:44px;height:40px;background-color:rgba(0,0,0,.5);clip-path:polygon(50% 0,100% 25%,100% 75%,50% 100%,0 75%,0 25%);transition:all .2s ease}.upgrade-icon:hover{background-color:var(--ui-accent-glow);transform:scale(1.1)}.modal-screen{position:absolute;top:0;left:0;width:100%;height:100%;background-color:var(--background-translucent);display:flex;flex-direction:column;justify-content:center;align-items:center;pointer-events:all;text-align:center;z-index:100;opacity:0;transition:opacity .5s ease;gap:20px}.modal-screen:not(.hidden){opacity:1}.modal-screen::before{content:'';position:absolute;top:0;left:0;right:0;bottom:0;background-image:linear-gradient(rgba(212,175,55,.05) 1px,transparent 1px),linear-gradient(90deg,rgba(212,175,55,.05) 1px,transparent 1px);background-size:40px 40px;animation:background-pan 30s linear infinite;z-index:-1}#upgrade-modal,#game-over-screen,#start-screen,#equipment-screen,#pause-screen{visibility:hidden}#upgrade-modal:not(.hidden),#game-over-screen:not(.hidden),#start-screen:not(.hidden),#equipment-screen:not(.hidden),#pause-screen:not(.hidden){visibility:visible}.hidden{opacity:0;pointer-events:none;visibility:hidden}#upgrade-choices-container{display:flex;gap:25px;justify-content:center;align-items:center}.upgrade-card{background:linear-gradient(145deg,#1a1a22,#111116);padding:20px;width:220px;height:350px;display:flex;flex-direction:column;align-items:center;justify-content:space-between;gap:15px;box-shadow:0 0 15px rgba(0,0,0,.5),inset 0 0 10px rgba(212,175,55,.2);transition:transform .3s ease,box-shadow .3s ease;border-radius:8px;border:2px solid}.upgrade-card.common{border-color:var(--rarity-common)}.upgrade-card.common:hover{box-shadow:0 0 25px var(--rarity-common),inset 0 0 10px rgba(255,255,255,.3);border-color:#fff}.upgrade-card.uncommon{border-color:var(--rarity-uncommon)}.upgrade-card.uncommon:hover{box-shadow:0 0 25px var(--rarity-uncommon),inset 0 0 10px rgba(30,255,0,.3);border-color:#fff}.upgrade-card.epic{border-color:var(--rarity-epic)}.upgrade-card.epic:hover{box-shadow:0 0 25px var(--rarity-epic),inset 0 0 10px rgba(156,39,176,.3);border-color:#fff}.upgrade-card.ascension{border-color:var(--rarity-ascension)}.upgrade-card.ascension:hover{box-shadow:0 0 25px var(--rarity-ascension),inset 0 0 10px rgba(255,193,7,.3);border-color:#fff}.upgrade-card:hover{transform:translateY(-15px) scale(1.03)}#upgrade-modal h1,#equipment-screen h1,#pause-screen h1{color:var(--ui-text);font-size:2.5em;text-transform:uppercase;letter-spacing:3px;margin-bottom:20px;text-shadow:0 0 10px var(--ui-accent-glow)}.upgrade-title{margin:0;font-size:1.6em;height:50px}.upgrade-title.common{color:var(--rarity-common);text-shadow:0 0 8px var(--rarity-common)}.upgrade-title.uncommon{color:var(--rarity-uncommon);text-shadow:0 0 8px var(--rarity-uncommon)}.upgrade-title.epic{color:var(--rarity-epic);text-shadow:0 0 8px var(--rarity-epic)}.upgrade-title.ascension{color:var(--rarity-ascension);text-shadow:0 0 8px var(--rarity-ascension)}.upgrade-glyph-canvas{width:80px;height:80px;filter:drop-shadow(0 0 8px var(--ui-accent))}.upgrade-description{margin:0;font-size:.95em;min-height:80px;flex-grow:1;color:#ccc;line-height:1.4}.general-button{padding:12px 30px;font-family:'Consolas','Courier New',monospace;font-size:1.2em;font-weight:700;text-transform:uppercase;background-color:transparent;color:var(--ui-accent);border:2px solid var(--ui-accent);border-radius:4px;cursor:pointer;transition:all .2s ease-out;box-shadow:0 0 10px transparent}.general-button:disabled{color:#777;border-color:#777;cursor:not-allowed;background-color:transparent!important;box-shadow:none!important;transform:none!important}.general-button:not(:disabled):hover{background-color:var(--ui-accent);color:var(--background-color);box-shadow:0 0 20px var(--ui-accent-glow);transform:scale(1.05)}#start-screen h1,#game-over-screen h1{font-size:5em;margin-bottom:10px;font-weight:700;text-transform:uppercase;animation:title-glow 4s ease-in-out infinite}#start-screen h1{color:var(--ui-accent)}#game-over-screen h1{color:var(--glyph-danger);text-shadow:0 0 15px var(--glyph-danger),0 0 30px var(--glyph-danger)}.final-stats-container{margin:20px 0;background:rgba(0,0,0,.3);padding:20px 40px;border:1px solid var(--glyph-danger);border-radius:8px}#game-over-screen p,#start-screen p{font-size:1.4em;margin:8px 0;color:#ccc}#start-screen p{font-size:1.2em}#equipment-container{display:flex;gap:50px;width:80%;max-width:1000px;justify-content:center;padding:10px 30px;max-height:520px;overflow-y:auto;box-sizing:border-box}#equipment-container::-webkit-scrollbar{width:8px}#equipment-container::-webkit-scrollbar-track{background:rgba(0,0,0,.3)}#equipment-container::-webkit-scrollbar-thumb{background-color:var(--ui-accent);border-radius:4px}#equipment-container::-webkit-scrollbar-thumb:hover{background-color:#ffdf80}.equipment-category{display:flex;flex-direction:column;gap:15px;align-items:center;flex:1}.equipment-category h2{margin:0 0 10px;font-size:1.8em;color:var(--ui-accent);text-shadow:0 0 8px var(--ui-accent-glow)}.equipment-card{background:linear-gradient(145deg,#1a1a22,#111116);padding:15px;width:100%;box-sizing:border-box;display:flex;flex-direction:column;align-items:center;gap:15px;border:2px solid #444;border-radius:4px;cursor:pointer;transition:all .2s ease}.equipment-card-header{display:flex;align-items:center;gap:15px;width:100%}.equipment-card.locked{border-color:#333;color:#888}.equipment-card.locked:hover{border-color:#555;transform:none}.equipment-card:not(.locked):hover{border-color:var(--ui-text);transform:scale(1.02)}.equipment-card.selected{border-color:var(--ui-accent);box-shadow:0 0 15px var(--ui-accent-glow);transform:scale(1.02)}.equipment-glyph-canvas{width:50px;height:50px;flex-shrink:0}.equipment-info{text-align:left}.equipment-info h3{margin:0;font-size:1.2em;color:var(--ui-text)}.equipment-info p{margin:5px 0 0;font-size:.85em;color:#aaa;line-height:1.3}.equipment-card.locked .equipment-info h3,.equipment-card.locked .equipment-info p{color:#888}.buy-button{padding:8px 20px;font-size:1em;margin-top:10px}.modal-actions{display:flex;gap:20px;margin-top:25px}#wave-announcer{position:absolute;top:25%;left:50%;transform:translateX(-50%) translateY(-50%);font-size:4em;color:var(--ui-accent);text-shadow:0 0 20px var(--ui-accent-glow);pointer-events:none;z-index:50;visibility:hidden;opacity:0}#wave-announcer.active{visibility:visible;animation:wave-announce-anim 3s ease-in-out forwards}

    </style>
</head>
<body>
    <div id="game-container">
        <div id="ground-image"></div>
        <div id="player-sprite"></div>

        <canvas id="gameCanvas"></canvas>
        <h1 id="wave-announcer"></h1>

        <div id="ui-container">
             <div class="hud-row">
                <div id="hud-top-left">
                    <div id="hp-bar-container"><div id="hp-bar"></div></div>
                    <span id="hp-text">50/50</span>
                </div>
                <div id="hud-top-right">
                    <span id="souls-text">Run Souls: 0</span>
                    <span id="total-souls-text">Total Souls: 0</span>
                    <span id="kills-text">Kills: 0</span>
                </div>
            </div>
             <div id="hud-top-center">
                <span id="timer-text">00:00</span>
                <span id="wave-text">Wave 1</span> 
                <span id="level-text">Level 1</span>
                <div id="xp-bar-container"><div id="xp-bar"></div></div>
            </div>
            <div class="hud-row">
                 <div id="hud-bottom-left" class="upgrade-tray">
                 </div>
            </div>
        </div>
        
        <div id="upgrade-modal" class="modal-screen hidden">
            <h1>Choose Your Arcana</h1>
            <div id="upgrade-choices-container">
            </div>
        </div>

        <div id="game-over-screen" class="modal-screen hidden">
            <h1>You Died</h1>
            <div class="final-stats-container">
                <p id="final-wave"></p> 
                <p id="final-time"></p>
                <p id="final-kills"></p>
                <p id="final-souls"></p>
            </div>
            <button id="restart-button" class="general-button">Try Again</button>
        </div>
        
        <div id="pause-screen" class="modal-screen hidden">
            <h1>Pausado</h1>
            <div class="modal-actions">
                <button id="continue-button" class="general-button">Continuar</button>
                <button id="menu-button" class="general-button">Voltar ao Menu</button>
            </div>
        </div>

        <div id="start-screen" class="modal-screen">
            <h1>Glyphcaster's Last Stand</h1>
            <p>Survive. Destroy. Evolve.</p>
            <p style="font-size: 1em; color: #999;">WASD: Mover | Mouse: Mirar | ESC: Pausar</p>
            <div class="modal-actions">
                <button id="start-button" class="general-button">Iniciar Jogo</button>
                <button id="equipment-button" class="general-button">Equipamento</button>
            </div>
        </div>
        
        <div id="equipment-screen" class="modal-screen hidden">
            <h1 id="equipment-total-souls">Total Souls: 0</h1> 
            <div id="equipment-container">
                <div class="equipment-category">
                    <h2>Cajados</h2>
                    <div id="staves-selection"></div>
                </div>
                <div class="equipment-category">
                    <h2>Roupões</h2>
                    <div id="robes-selection"></div>
                </div>
            </div>
            <div class="modal-actions">
                <button id="back-to-menu-button" class="general-button">Voltar</button>
            </div>
        </div>
    </div>

<script>
'use strict';

// --- MODIFICADO: A variável ZOOM_FACTOR não é mais necessária, simplificando as coordenadas ---
const CANVAS_WIDTH = 1366;
const CANVAS_HEIGHT = 768;
// const ZOOM_FACTOR = 0.8; // Removido

const BACKGROUND_COLOR = '#0d0d12'; 
const GLYPH_COLOR_PRIMARY = '#FFFFFF';
const GLYPH_COLOR_DANGER = '#FF0000';
const PARTICLE_PALETTE = ['#FF00FF', '#FFFF00', '#FF4500', '#F08080'];
const UI_ACCENT_COLOR = '#D4AF37';
const UI_TEXT_COLOR = '#EAEAEA';
const DAMAGE_TEXT_NORMAL_COLOR = '#FFFFFF';
const DAMAGE_TEXT_CRIT_COLOR = '#FF4500';
const GRAVITY = 1200.0;
const MAX_FALL_SPEED = 700.0;
const PLAYER_ACCELERATION = 1000.0;
const PLAYER_FRICTION_MULTIPLIER = 0.88;
const BASE_PLAYER_MAX_SPEED_X = 300.0;
const BASE_PLAYER_JUMP_FORCE = 550.0;
const PLAYER_COYOTE_TIME = 0.1; 
const PLAYER_JUMP_BUFFER_TIME = 0.1; 
const INITIAL_PLAYER_HP = 50;
const BASE_ATTACK_SPEED = 1.0;
const BASE_ATTACK_DAMAGE = 5;
const BASE_PROJECTILE_SPEED = 600;
const BASE_CRIT_CHANCE = 0.05;
const BASE_CRIT_MULTIPLIER = 2.0;
const BASE_SOUL_DROP_CHANCE = 0.1;
const BASE_KNOCKBACK_FORCE = 150; 
const BEAM_TICK_RATE = 10;
const GameState = Object.freeze({ MENU: 'MENU', EQUIPMENT_SELECTION: 'EQUIPMENT_SELECTION', PLAYING: 'PLAYING', PAUSED: 'PAUSED', UPGRADE_CHOICE: 'UPGRADE_CHOICE', GAME_OVER: 'GAME_OVER' });
const AIState = Object.freeze({ SPAWNING: 'SPAWNING', HOMING: 'HOMING', ATTACKING: 'ATTACKING' });

class PlayerDataManager {
    constructor() {
        this.data = {};
        this.storageKey = 'glyphcaster_save_data';
    }

    load() {
        try {
            const savedData = localStorage.getItem(this.storageKey);
            if (savedData) {
                this.data = JSON.parse(savedData);
            } else {
                this.resetData();
            }
        } catch (e) {
            console.error("Failed to load player data:", e);
            this.resetData();
        }
    }

    save() {
        try {
            localStorage.setItem(this.storageKey, JSON.stringify(this.data));
        } catch (e) {
            console.error("Failed to save player data:", e);
        }
    }

    resetData() {
        this.data = {
            totalSouls: 0,
            unlockedStaves: ['wizards_staff'],
            unlockedRobes: ['wizards_hat']
        };
        this.save();
    }
    
    isUnlocked(type, id) {
        if (type === 'staves') return this.data.unlockedStaves.includes(id);
        if (type === 'robes') return this.data.unlockedRobes.includes(id);
        return false;
    }

    unlockItem(type, id) {
        if (type === 'staves' && !this.data.unlockedStaves.includes(id)) {
            this.data.unlockedStaves.push(id);
        } else if (type === 'robes' && !this.data.unlockedRobes.includes(id)) {
            this.data.unlockedRobes.push(id);
        }
        this.save();
    }
    
    spendSouls(amount) {
        if (this.data.totalSouls >= amount) {
            this.data.totalSouls -= amount;
            this.save();
            return true;
        }
        return false;
    }
}

class Vec2 {
    constructor(x = 0, y = 0) { this.x = x; this.y = y; }
    add(v) { return new Vec2(this.x + v.x, this.y + v.y); }
    sub(v) { return new Vec2(this.x - v.x, this.y - v.y); }
    scale(s) { return new Vec2(this.x * s, this.y * s); }
    mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
    magSq() { return this.x * this.x + this.y * this.y; }
    normalize() { const m = this.mag(); return m > 0 ? new Vec2(this.x / m, this.y / m) : new Vec2(); }
}

class InputHandler {
    constructor() {
        this.keys = new Set();
        this.mousePos = { x: 0, y: 0 };
        this.isMouseDown = false;
        window.addEventListener('keydown', e => this.keys.add(e.key.toLowerCase()));
        window.addEventListener('keyup', e => this.keys.delete(e.key.toLowerCase()));
        window.addEventListener('mousemove', e => this.updateMousePos(e));
        window.addEventListener('mousedown', () => this.isMouseDown = true);
        window.addEventListener('mouseup', () => this.isMouseDown = false);
    }
    updateMousePos(e) {
        const canvas = document.getElementById('gameCanvas');
        if (!canvas) return;
        const rect = canvas.getBoundingClientRect();
        
        const screenX = (e.clientX - rect.left);
        const screenY = (e.clientY - rect.top);
        
        this.mousePos.x = screenX;
        this.mousePos.y = screenY;
    }
    isDown(key) { return this.keys.has(key); }
}

class Particle {
    constructor(x, y, vx, vy, life, color, size, gravityEffect) {
        this.pos = new Vec2(x, y);
        this.vel = new Vec2(vx, vy);
        this.life = life;
        this.initialLife = life;
        this.color = color;
        this.size = size;
        this.gravityEffect = gravityEffect;
    }
    update(dt) {
        this.life -= dt;
        this.vel.y += GRAVITY * this.gravityEffect * dt;
        this.pos = this.pos.add(this.vel.scale(dt));
    }
    draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.globalAlpha = Math.max(0, this.life / this.initialLife);
        ctx.beginPath();
        ctx.arc(this.pos.x, this.pos.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
    }
}

class Platform {
    constructor(x, y, width) {
        this.p1 = { x: x, y: y };
        this.p2 = { x: x + width, y: y };
        this.width = width;
    }
    draw(renderer) {
    }
}

class Entity {
    constructor(x, y, width, height) {
        this.pos = new Vec2(x, y);
        this.vel = new Vec2(0, 0);
        this.width = width;
        this.height = height;
        this.isDead = false;
        this.collisionRadius = Math.max(width, height) / 2;
        this.friction = 0.95;
        this.hitFlashTimer = 0;
    }
    applyPhysics(dt) {
        if (this.hitFlashTimer > 0) this.hitFlashTimer -= dt;
        this.vel.y += GRAVITY * dt;
        this.vel.y = Math.min(this.vel.y, MAX_FALL_SPEED);
        this.vel.x *= this.friction; 
        this.pos = this.pos.add(this.vel.scale(dt));
    }
}

class Renderer {
    constructor(canvas, ctx) {
        this.canvas = canvas;
        this.ctx = ctx;
        this.lightRayOpacity = 0.05;
    }
    
    clear() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }

    drawGlyph(ctx, points, x, y, angle = 0, scale = 1, options = {}) {
        const { color = GLYPH_COLOR_PRIMARY, lineWidth = 2, shadowColor = 'rgba(0,0,0,0.7)', shadowBlur = 5, shadowOffsetX = 3, shadowOffsetY = 3, glowColor = null, glowBlur = 15 } = options;
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        ctx.scale(scale, scale);
        ctx.shadowColor = shadowColor;
        ctx.shadowBlur = shadowBlur;
        ctx.shadowOffsetX = shadowOffsetX;
        ctx.shadowOffsetY = shadowOffsetY;
        ctx.strokeStyle = color;
        ctx.lineWidth = lineWidth;
        ctx.beginPath();
        if (points.length > 0) {
           ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
        }
        ctx.closePath();
        ctx.stroke();
        ctx.shadowBlur = 0;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        if (glowColor) {
            ctx.shadowColor = glowColor;
            ctx.shadowBlur = glowBlur;
        }
        ctx.stroke();
        ctx.restore();
    }
    drawLightRays(playerPos) {
        if (!playerPos) return;
        const ctx = this.ctx;
        const rayCount = 12;
        ctx.save();
        ctx.globalAlpha = this.lightRayOpacity;
        ctx.strokeStyle = UI_ACCENT_COLOR;
        ctx.lineWidth = 1;
        for (let i = 0; i < rayCount; i++) {
            const angle = (i / rayCount) * Math.PI * 2 + game.gameTime * 0.1;
            const endX = playerPos.x + Math.cos(angle) * 3000;
            const endY = playerPos.y + Math.sin(angle) * 3000;
            ctx.beginPath();
            ctx.moveTo(playerPos.x, playerPos.y);
            ctx.lineTo(endX, endY);
            ctx.stroke();
        }
        ctx.restore();
    }
    drawVignette(playerPos) {
        const ctx = this.ctx;
        ctx.save();
        const centerX = this.canvas.width / 2;
        const centerY = this.canvas.height / 2;
        const gradient = ctx.createRadialGradient(centerX, centerY, 300, centerX, centerY, Math.max(this.canvas.width, this.canvas.height) * 0.9);
        gradient.addColorStop(0, 'rgba(0,0,0,0)');
        gradient.addColorStop(1, 'rgba(0,0,0,0.8)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        ctx.restore();
    }
}

class UIManager {
    constructor() {
        this.hpBar = document.getElementById('hp-bar');
        this.hpText = document.getElementById('hp-text');
        this.xpBar = document.getElementById('xp-bar');
        this.levelText = document.getElementById('level-text');
        this.soulsText = document.getElementById('souls-text');
        this.totalSoulsText = document.getElementById('total-souls-text');
        this.killsText = document.getElementById('kills-text');
        this.timerText = document.getElementById('timer-text');
        this.waveText = document.getElementById('wave-text');
        this.waveAnnouncer = document.getElementById('wave-announcer');
        this.upgradeTray = document.getElementById('hud-bottom-left');
        this.upgradeModal = document.getElementById('upgrade-modal');
        this.upgradeChoicesContainer = document.getElementById('upgrade-choices-container');
        this.gameOverScreen = document.getElementById('game-over-screen');
        this.finalWave = document.getElementById('final-wave');
        this.finalTime = document.getElementById('final-time');
        this.finalKills = document.getElementById('final-kills');
        this.finalSouls = document.getElementById('final-souls');
        this.startScreen = document.getElementById('start-screen');
        this.equipmentScreen = document.getElementById('equipment-screen');
        this.equipmentTotalSouls = document.getElementById('equipment-total-souls');
        this.pauseScreen = document.getElementById('pause-screen');
    }

    update(player, game) {
        this.hpBar.style.width = `${(player.hp / player.stats.maxHp) * 100}%`;
        this.hpText.textContent = `${Math.ceil(player.hp)}/${player.stats.maxHp}`;
        this.soulsText.textContent = `Run Souls: ${player.runSouls}`;
        this.totalSoulsText.textContent = `Total Souls: ${game.playerDataManager.data.totalSouls}`;
        this.killsText.textContent = `Kills: ${game.kills}`;
        const xpPercent = (player.xp / player.xpToNextLevel()) * 100;
        this.xpBar.style.width = `${xpPercent}%`;
        this.levelText.textContent = `Level ${player.level}`;
        this.waveText.textContent = game.waveState === 'INTERMISSION' ? 'Intermission' : `Wave ${game.currentWave}`;
        const minutes = Math.floor(game.gameTime / 60).toString().padStart(2, '0');
        const seconds = Math.floor(game.gameTime % 60).toString().padStart(2, '0');
        this.timerText.textContent = `${minutes}:${seconds}`;
    }

    showUpgradeChoices(choices) {
        this.upgradeChoicesContainer.innerHTML = ''; 
        choices.forEach((upgrade, index) => {
            let description = upgrade.description;
            if (upgrade.generateDescription) {
                description = upgrade.generateDescription(game.player);
            }

            const cardHTML = `
                <div class="upgrade-card ${upgrade.rarity}" id="upgrade-card-${index}">
                    <h2 class="upgrade-title ${upgrade.rarity}">${upgrade.name}</h2>
                    <canvas class="upgrade-glyph-canvas" id="upgrade-glyph-canvas-${index}" width="80" height="80"></canvas>
                    <p class="upgrade-description">${description}</p>
                    <button class="general-button" id="accept-button-${index}">accept</button>
                </div>
            `;
            this.upgradeChoicesContainer.innerHTML += cardHTML;
        });
        choices.forEach((upgrade, index) => {
            const canvas = document.getElementById(`upgrade-glyph-canvas-${index}`);
            const ctx = canvas.getContext('2d');
            const renderer = new Renderer(canvas, ctx);
            const rarityColor = getComputedStyle(document.documentElement).getPropertyValue(`--rarity-${upgrade.rarity}`).trim();
            renderer.clear();
            renderer.drawGlyph(ctx, upgrade.glyph, 40, 40, 0, 3.5, { color: rarityColor, glowColor: rarityColor, glowBlur: 20, shadowBlur: 0 });
            document.getElementById(`accept-button-${index}`).onclick = () => { game.selectUpgrade(upgrade); };
        });
        this.upgradeModal.classList.remove('hidden');
    }
    hideUpgradeModal() { this.upgradeModal.classList.add('hidden'); }
    addUpgradeIcon(upgrade) {
        const iconCanvas = document.createElement('canvas');
        iconCanvas.width = 44;
        iconCanvas.height = 40;
        iconCanvas.classList.add('upgrade-icon');
        const iconCtx = iconCanvas.getContext('2d');
        const renderer = new Renderer(iconCanvas, iconCtx);
        const rarityColor = getComputedStyle(document.documentElement).getPropertyValue(`--rarity-${upgrade.rarity}`).trim();
        renderer.drawGlyph(iconCtx, upgrade.glyph, 22, 20, 0, 1.8, { color: rarityColor, lineWidth: 1.5, shadowBlur: 0 });
        this.upgradeTray.appendChild(iconCanvas);
    }
    showGameOver(game) {
        this.finalWave.textContent = `Reached Wave: ${game.currentWave}`;
        this.finalTime.textContent = `Time Survived: ${this.timerText.textContent}`;
        this.finalKills.textContent = `Enemies Destroyed: ${game.kills}`;
        this.finalSouls.textContent = `Souls Collected: ${game.player.runSouls}`;
        this.gameOverScreen.classList.remove('hidden');
    }
    hideGameOver() { this.gameOverScreen.classList.add('hidden'); }
    showStartScreen() { this.startScreen.classList.remove('hidden'); }
    hideStartScreen() { this.startScreen.classList.add('hidden'); }
    showEquipmentScreen() { this.equipmentScreen.classList.remove('hidden'); }
    hideEquipmentScreen() { this.equipmentScreen.classList.add('hidden'); }
    showPauseScreen() { this.pauseScreen.classList.remove('hidden'); }
    hidePauseScreen() { this.pauseScreen.classList.add('hidden'); }
    
    showWaveAnnouncer(waveNumber) {
        this.waveAnnouncer.textContent = `WAVE ${waveNumber}`;
        this.waveAnnouncer.classList.add('active');
        setTimeout(() => {
            this.waveAnnouncer.classList.remove('active');
        }, 3000);
    }
}

class FloatingText {
    constructor(text, x, y, color = DAMAGE_TEXT_NORMAL_COLOR, size = 16, isCrit = false) {
        this.text = text;
        this.pos = new Vec2(x, y);
        this.life = 1.0;
        this.vel = new Vec2((Math.random() - 0.5) * 30, -80);
        this.color = color;
        this.size = size;
        this.isCrit = isCrit;
    }
    update(dt) {
        this.life -= dt;
        this.pos = this.pos.add(this.vel.scale(dt));
        this.vel.y += GRAVITY * 0.3 * dt;
    }
    draw(ctx) {
        ctx.save();
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color;
        ctx.font = `bold ${this.size}px 'Consolas', monospace`;
        ctx.textAlign = 'center';
        if (this.isCrit) {
            ctx.shadowColor = DAMAGE_TEXT_CRIT_COLOR;
            ctx.shadowBlur = 10;
        }
        ctx.fillText(this.text, this.pos.x, this.pos.y);
        ctx.restore();
    }
}

class WillOWisp extends Entity {
    constructor(owner) {
        super(owner.pos.x, owner.pos.y, 16, 16);
        this.owner = owner;
        this.orbitAngle = Math.random() * Math.PI * 2;
        this.orbitRadius = 80;
        this.fireTimer = 0;
        this.glyph = GLYPH_DATA.WISP;
    }
    update(dt, enemies) {
        this.applyPhysics(dt);
        this.orbitAngle += 2 * dt;
        const targetPos = new Vec2(this.owner.pos.x + Math.cos(this.orbitAngle) * this.orbitRadius, this.owner.pos.y + Math.sin(this.orbitAngle) * this.orbitRadius - 30);
        this.pos = this.pos.add(targetPos.sub(this.pos).scale(10 * dt));
        this.fireTimer -= dt;
        const fireRate = this.owner.stats.attackSpeed * 0.5;
        if (this.fireTimer <= 0) {
            const nearestEnemy = this.findNearestEnemy(enemies);
            if (nearestEnemy) {
                this.shoot(nearestEnemy);
                this.fireTimer = 1 / fireRate;
            }
        }
    }
    findNearestEnemy(enemies) {
        let closest = null;
        let closestDistSq = Infinity;
        for (const enemy of enemies) {
            if(enemy.isDead) continue;
            const distSq = this.pos.sub(enemy.pos).magSq();
            if (distSq < closestDistSq) {
                closest = enemy;
                closestDistSq = distSq;
            }
        }
        return closest;
    }
    shoot(target) {
        const angle = Math.atan2(target.pos.y - this.pos.y, target.pos.x - this.pos.x);
        const projectile = new Projectile(this.pos.x, this.pos.y, 2, angle, 'player');
        projectile.damage = this.owner.stats.attackDamage * 0.5;
        projectile.speed = 400;
        projectile.color = PARTICLE_PALETTE[1];
        game.projectiles.push(projectile);
    }
    draw(renderer) {
        const color = this.hitFlashTimer > 0 ? '#FFFFFF' : PARTICLE_PALETTE[1];
        renderer.drawGlyph(renderer.ctx, this.glyph, this.pos.x, this.pos.y, this.orbitAngle, 1, { color: color, glowColor: color, glowBlur: 10 });
    }
}


class LightningBolt {
    constructor(target, damage) {
        this.target = target;
        this.life = 0.3;
        this.strikeTimer = 0.1;
        this.points = [];
        this.isStruck = false;
        this.damage = damage;
    }
    update(dt) {
        this.life -= dt;
        this.strikeTimer -= dt;
        if (this.strikeTimer <= 0 && !this.isStruck) {
            this.isStruck = true;
            if(this.target && !this.target.isDead) {
                this.target.takeDamage(this.damage, {type: 'crit'});
                game.particleEngine.createEnemyDeathExplosion(this.target.pos.x, this.target.pos.y, 1.5, PARTICLE_PALETTE[1]);
            }
            game.triggerScreenShake(8, 0.15);
            game.triggerFlash(0.1, PARTICLE_PALETTE[1]);
            let start = new Vec2(this.target ? this.target.pos.x : Math.random() * CANVAS_WIDTH, this.target.pos.y - CANVAS_HEIGHT);
            this.points.push(start);
            let current = start;
            const endY = this.target ? this.target.pos.y : CANVAS_HEIGHT;
            while(current.y < endY) {
                const nextY = current.y + Math.random() * 30 + 10;
                const nextX = current.x + (Math.random() - 0.5) * 20;
                current = new Vec2(nextX, Math.min(nextY, endY));
                this.points.push(current);
            }
        }
    }
    draw(ctx) {
        if (!this.isStruck) return;
        ctx.save();
        ctx.strokeStyle = PARTICLE_PALETTE[1];
        ctx.lineWidth = 4;
        ctx.globalAlpha = Math.max(0, this.life / 0.2);
        ctx.shadowColor = PARTICLE_PALETTE[1];
        ctx.shadowBlur = 15;
        ctx.beginPath();
        if (this.points.length > 0) {
            ctx.moveTo(this.points[0].x, this.points[0].y);
            for(let i = 1; i < this.points.length; i++) { ctx.lineTo(this.points[i].x, this.points[i].y); }
        }
        ctx.stroke();
        ctx.restore();
    }
}

class LightningBoltGenerator {
    constructor(boltCount, interval, damageMultiplier = 1) { 
        this.boltCount = boltCount;
        this.interval = interval;
        this.damageMultiplier = damageMultiplier;
        this.timer = 0; 
        this.isDead = false; 
    }
    update(dt, enemies, game) {
        this.timer -= dt;
        if (this.timer <= 0 && enemies.length > 0) {
            this.timer = this.interval;
            for(let i = 0; i < this.boltCount; i++) {
                const randomEnemy = enemies[Math.floor(Math.random() * enemies.length)];
                const damage = (20 + game.player.level * 5) * this.damageMultiplier;
                game.effects.push(new LightningBolt(randomEnemy, damage));
            }
        }
    }
    draw() {}
}

class Projectile extends Entity {
    constructor(x, y, size, angle, owner) {
        super(x, y, size * 2, size * 2);
        this.size = size;
        this.angle = angle;
        this.owner = owner;
        this.speed = BASE_PROJECTILE_SPEED;
        this.damage = BASE_ATTACK_DAMAGE;
        this.color = PARTICLE_PALETTE[0];
        this.vel.x = Math.cos(angle) * this.speed;
        this.vel.y = Math.sin(angle) * this.speed;
        this.life = 2.0;
        this.hitsLeft = 1;
        this.knockbackForce = BASE_KNOCKBACK_FORCE;
        this.trailTimer = 0;
        this.isExplosive = false;
        this.isHoming = false;
        this.homingTarget = null;
    }
    update(dt) {
        this.life -= dt;
        if (this.life <= 0 || this.hitsLeft <= 0) this.isDead = true;

        if (this.isHoming) {
            if (!this.homingTarget || this.homingTarget.isDead) {
                this.findHomingTarget(game.enemies);
            }
            if (this.homingTarget) {
                const targetDir = this.homingTarget.pos.sub(this.pos).normalize();
                const currentDir = this.vel.normalize();
                const newDir = currentDir.add(targetDir.sub(currentDir).scale(4 * dt)).normalize();
                this.vel = newDir.scale(this.speed);
            }
        }

        this.pos = this.pos.add(this.vel.scale(dt));
        this.trailTimer -= dt;
        if (this.trailTimer <= 0) {
            game.particleEngine.createTrail(this.pos.x, this.pos.y, this.color);
            this.trailTimer = 0.02;
        }

        if (this.isDead && this.isExplosive) {
            this.explode();
        }
    }
    draw(ctx) {
        ctx.save();
        ctx.fillStyle = this.color;
        ctx.shadowColor = this.color;
        ctx.shadowBlur = 10;
        ctx.beginPath();
        const finalSize = this.size * (this.owner === 'player' ? game.player.stats.projectileSize : 1);
        ctx.arc(this.pos.x, this.pos.y, finalSize, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }
    findHomingTarget(enemies) {
        let closestDistSq = Infinity;
        this.homingTarget = null;
        for (const enemy of enemies) {
            if (enemy.isDead) continue;
            const distSq = this.pos.sub(enemy.pos).magSq();
            if (distSq < closestDistSq) {
                closestDistSq = distSq;
                this.homingTarget = enemy;
            }
        }
    }
    explode() {
        game.particleEngine.create(30, this.pos.x, this.pos.y, {
            minSpeed: 50, maxSpeed: 200, minLife: 0.4, maxLife: 0.8,
            minSize: 1, maxSize: 4, colors: [PARTICLE_PALETTE[2], PARTICLE_PALETTE[3]], gravityEffect: 0.2
        });
        for (const enemy of game.enemies) {
            if (enemy.isDead) continue;
            if (this.pos.sub(enemy.pos).magSq() < 80 * 80) { // 80px radius
                enemy.takeDamage(this.damage, { knockbackDir: enemy.pos.sub(this.pos).normalize(), knockbackForce: this.knockbackForce * 2 });
            }
        }
    }
}

class Enemy extends Entity {
    constructor(x, y, type = 'peon') {
        const stats = ENEMY_DATA[type];
        super(x, y, stats.width, stats.height);
        this.hp = stats.hp;
        this.maxHp = stats.hp;
        this.damage = stats.damage;
        this.baseSpeed = stats.speed;
        this.glyph = stats.glyph;
        this.xpValue = stats.xp;
        this.aiState = AIState.HOMING;
        this.homingOffset = new Vec2((Math.random() - 0.5) * 80, (Math.random() - 0.5) * 80);
        this.friction = 0.98;
        this.attackCooldown = 5.0 + Math.random() * 2.0; 
        this.attackThresholdY = (CANVAS_HEIGHT / 2) + (Math.random() - 0.5) * 100;
        this.statusEffects = [];
        this.slowMultiplier = 1.0;
    }
    
    update(dt, player, platforms) {
        if (this.hitFlashTimer > 0) this.hitFlashTimer -= dt;
        
        this.statusEffects.forEach(effect => effect.update(dt, this));
        this.statusEffects = this.statusEffects.filter(effect => !effect.isFinished);

        if (player.isDead) {
            this.vel = this.vel.scale(this.friction);
            this.pos = this.pos.add(this.vel.scale(dt));
            return;
        }

        const currentSpeed = this.baseSpeed * this.slowMultiplier;

        if (this.aiState === AIState.HOMING && this.pos.y > this.attackThresholdY) {
            this.aiState = AIState.ATTACKING;
        }
        let targetY = player.pos.y - 100;
        if (this.aiState === AIState.ATTACKING) {
            targetY = this.pos.y;
        }
        const minY = 80;
        const maxY = CANVAS_HEIGHT - 200;
        targetY = Math.max(minY, Math.min(maxY, targetY));

        const targetPos = new Vec2(player.pos.x + this.homingOffset.x, targetY + this.homingOffset.y / 2);
        const desiredVelocity = targetPos.sub(this.pos).normalize().scale(currentSpeed);
        const steeringForce = desiredVelocity.sub(this.vel);
        this.vel = this.vel.add(steeringForce.scale(5 * dt));
        this.vel = this.vel.scale(this.friction);
        this.pos = this.pos.add(this.vel.scale(dt));

        if (this.aiState === AIState.ATTACKING) {
            this.attackCooldown -= dt;
            if (this.attackCooldown <= 0) {
                this.shoot(player);
                this.attackCooldown = 5.0 + Math.random() * 2.0;
            }
        }
    }

    shoot(player) {
        const angle = Math.atan2(player.pos.y - this.pos.y, player.pos.x - this.pos.x);
        const projectile = new Projectile(this.pos.x, this.pos.y, 4, angle, 'enemy');
        projectile.damage = this.damage;
        projectile.speed = 300; 
        projectile.color = GLYPH_COLOR_DANGER;
        game.projectiles.push(projectile);
    }

    draw(renderer) {
        const color = this.hitFlashTimer > 0 ? '#FFFFFF' : GLYPH_COLOR_DANGER;
        renderer.drawGlyph(renderer.ctx, this.glyph, this.pos.x, this.pos.y, 0, 1, { color: color, glowColor: GLYPH_COLOR_DANGER, glowBlur: 10 });
    }
    
    takeDamage(amount, options = {}) {
        const { type = 'normal', knockbackDir, knockbackForce = 0, source = null } = options;
        if (this.isDead) return;

        let finalDamage = amount;
        this.hitFlashTimer = 0.15;
        const isCrit = type !== 'no-crit' && (type === 'crit' || Math.random() < game.player.stats.critChance);
        let textColor = DAMAGE_TEXT_NORMAL_COLOR;
        if (isCrit) {
            finalDamage *= game.player.stats.critDamageMultiplier;
            textColor = DAMAGE_TEXT_CRIT_COLOR;
        }
        this.hp -= finalDamage;

        game.player.onHit(this, finalDamage);

        game.effects.push(new FloatingText(Math.round(finalDamage), this.pos.x, this.pos.y, textColor, isCrit ? 22 : 16, isCrit));
        if (knockbackDir) { this.vel = this.vel.add(knockbackDir.scale(knockbackForce)); }
        if (this.hp <= 0) {
            this.isDead = true;
            game.player.onKill(this);
            game.kills++;
            game.particleEngine.createEnemyDeathExplosion(this.pos.x, this.pos.y);
            game.triggerScreenShake(3, 0.1);
            game.triggerHitStop(0.05);
            game.triggerFlash(0.08, GLYPH_COLOR_DANGER);
        } else {
            game.triggerHitStop(0.02);
        }
    }
    
    applyStatusEffect(effect) {
        const existing = this.statusEffects.find(e => e.id === effect.id);
        if (existing) {
            existing.refresh(effect);
        } else {
            this.statusEffects.push(effect);
        }
    }
}

class Player extends Entity {
    constructor(x, y) {
        super(x, y, 20, 40);
        this.staffLength = 30;
        this.aimAngle = 0;
        this.init();
    }
    init() {
        this.isDead = false;
        this.pos = new Vec2(CANVAS_WIDTH / 2, CANVAS_HEIGHT - 200); 
        
        this.spriteElement = document.getElementById('player-sprite');
        if (this.spriteElement) {
            this.spriteElement.style.display = 'block';
        }

        this.vel = new Vec2(0, 0);
        this.hp = INITIAL_PLAYER_HP;
        this.runSouls = 0;
        this.xp = 0;
        this.level = 1;
        this.equipment = {}; 

        this.stats = { 
            maxHp: INITIAL_PLAYER_HP, 
            attackSpeed: BASE_ATTACK_SPEED, 
            attackDamage: BASE_ATTACK_DAMAGE, 
            projectileSpeed: BASE_PROJECTILE_SPEED,
            critChance: BASE_CRIT_CHANCE, 
            critDamageMultiplier: BASE_CRIT_MULTIPLIER, 
            lifeSteal: 0, 
            projectileHits: 1, 
            soulDropChance: BASE_SOUL_DROP_CHANCE,
            defense: 0,
            jumpHeightMultiplier: 1,
            moveSpeedMultiplier: 1,
            projectileSize: 1,
            invulnOnHitDuration: 0,
            luck: 0,
            bodyDamage: 0,
            bonusUpgradeChoices: 0,
        };

        this.attackCooldown = 0;
        this.isGrounded = false;
        this.coyoteTimer = 0;
        this.jumpBufferTimer = 0;
        this.scale = {x: 1, y: 1};
        this.activeUpgrades = new Map();
        
        this.wisps = [];
        this.hasStreamer = false;
        this.beamTickTimer = 0;
        this.applyBeamDamageThisFrame = false;
        this.maxJumps = 1;
        this.jumpsLeft = 1;
        this.invulnTimer = 0;
        this.distanceWalked = 0;
        this.revives = 0;

    }
    xpToNextLevel() { return 50 + this.level * 25; }
    
    update(dt, platforms, input, game) {
        if (this.hitFlashTimer > 0) this.hitFlashTimer -= dt;
        if (this.invulnTimer > 0) this.invulnTimer -= dt;
        if (this.isDead) return;

        let accelerationX = 0;
        if (input.isDown('a') || input.isDown('arrowleft')) accelerationX -= PLAYER_ACCELERATION;
        if (input.isDown('d') || input.isDown('arrowright')) accelerationX += PLAYER_ACCELERATION;
        
        const lastX = this.pos.x;
        const playerMaxSpeedX = BASE_PLAYER_MAX_SPEED_X * this.stats.moveSpeedMultiplier;

        if (accelerationX !== 0) { this.vel.x += accelerationX * dt; } else { this.vel.x *= PLAYER_FRICTION_MULTIPLIER; }
        this.vel.x = Math.max(-playerMaxSpeedX, Math.min(playerMaxSpeedX, this.vel.x));
        
        this.distanceWalked += Math.abs(this.pos.x - lastX) * dt;
        if (this.stats.frictionProjectiles > 0 && this.distanceWalked >= 1) {
            this.distanceWalked -= 1;
            for(let i=0; i<this.stats.frictionProjectiles; i++){
                 const p = new Projectile(this.pos.x, this.pos.y, 5, -Math.PI/2, 'player');
                 p.damage = 10;
                 p.color = '#FFA500';
                 game.projectiles.push(p);
            }
        }
        
        this.aimAngle = Math.atan2(input.mousePos.y - this.pos.y, input.mousePos.x - this.pos.x);
        this.attackCooldown -= dt;
        this.applyBeamDamageThisFrame = false;

        if (this.hasStreamer && input.isMouseDown) {
            this.beamTickTimer -= dt;
            if (this.beamTickTimer <= 0) {
                this.applyBeamDamageThisFrame = true;
                this.beamTickTimer = 1 / BEAM_TICK_RATE;
            }
        } else if (input.isMouseDown && this.attackCooldown <= 0) {
            this.shoot(game);
            this.attackCooldown = 1 / this.stats.attackSpeed;
        }

        this.coyoteTimer -= dt;
        this.jumpBufferTimer -= dt;
        if (input.isDown('w') || input.isDown('arrowup') || input.isDown(' ')) { 
            if(!this.jumpKeyPressed) this.jumpBufferTimer = PLAYER_JUMP_BUFFER_TIME; 
            this.jumpKeyPressed = true;
        } else {
             this.jumpKeyPressed = false;
        }

        if (this.jumpBufferTimer > 0) {
            if (this.isGrounded || this.coyoteTimer > 0) {
                this.jump();
                this.jumpBufferTimer = 0;
                this.coyoteTimer = 0;
            } else if(this.jumpsLeft > 1) {
                this.jump();
                this.jumpBufferTimer = 0;
            }
        }

        this.vel.y += GRAVITY * dt;
        this.vel.y = Math.min(this.vel.y, MAX_FALL_SPEED);
        this.pos.x += this.vel.x * dt;
        this.pos.y += this.vel.y * dt;

        const worldLeftBoundary = 0 + this.width / 2;
        const worldRightBoundary = CANVAS_WIDTH - this.width / 2;
        if (this.pos.x < worldLeftBoundary) {
            this.pos.x = worldLeftBoundary;
            this.vel.x = 0;
        } else if (this.pos.x > worldRightBoundary) {
            this.pos.x = worldRightBoundary;
            this.vel.x = 0;
        }
        
        const wasGrounded = this.isGrounded;
        this.isGrounded = false;
        const collisionPoints = [{ x: this.pos.x - this.width / 4, y: this.pos.y + this.height / 2 }, { x: this.pos.x, y: this.pos.y + this.height / 2 }, { x: this.pos.x + this.width / 4, y: this.pos.y + this.height / 2 }];
        
        for (const platform of platforms) {
            for (const point of collisionPoints) {
                const prevY = point.y - this.vel.y * dt;
                if (point.x >= platform.p1.x && point.x <= platform.p2.x && prevY <= platform.p1.y && point.y >= platform.p1.y) {
                    if (this.vel.y > 0) { 
                        this.pos.y = platform.p1.y - this.height / 2; 
                        this.vel.y = 0; 
                        if (!wasGrounded) this.land(); 
                        this.isGrounded = true; 
                        this.coyoteTimer = PLAYER_COYOTE_TIME; 
                        this.jumpsLeft = this.maxJumps;
                        break; 
                    }
                }
            }
            if(this.isGrounded) break;
        }

        this.scale.x += (1 - this.scale.x) * 0.2;
        this.scale.y += (1 - this.scale.y) * 0.2;
        
        this.wisps.forEach(wisp => wisp.update(dt, game.enemies));
    }

    draw() {
        if (!this.spriteElement) return;

        this.spriteElement.style.left = `${this.pos.x}px`;
        this.spriteElement.style.top = `${this.pos.y}px`;

        const isFlipped = game.inputHandler.mousePos.x < this.pos.x;
        this.spriteElement.classList.toggle('flipped', isFlipped);
    }
    
    drawStreamer(ctx, startX, startY) {
        const endX = this.pos.x + Math.cos(this.aimAngle) * 3000;
        const endY = this.pos.y + Math.sin(this.aimAngle) * 3000;
        ctx.save();
        ctx.strokeStyle = PARTICLE_PALETTE[0];
        ctx.lineWidth = 4 + Math.sin(game.gameTime * 20) * 2;
        ctx.globalAlpha = 0.8;
        ctx.shadowColor = PARTICLE_PALETTE[0];
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(endX, endY);
        ctx.stroke();
        ctx.restore();
    }
    
    jump() {
        if (this.equipment.hasPropellerBeanie) {
             this.vel.y = -BASE_PLAYER_JUMP_FORCE; 
        } else {
             this.vel.y = -BASE_PLAYER_JUMP_FORCE * this.stats.jumpHeightMultiplier;
        }
        this.jumpsLeft--;
        game.particleEngine.createJumpDust(this.pos.x, this.pos.y + this.height / 2);
        this.scale = { x: 0.8, y: 1.2 }; 
    }
    
    land() {
        game.particleEngine.createJumpDust(this.pos.x, this.pos.y + this.height / 2);
        this.scale = { x: 1.2, y: 0.8 }; 
    }
    
    shoot(game) {
        const staffTipX = this.pos.x + Math.cos(this.aimAngle) * this.staffLength;
        const staffTipY = this.pos.y + Math.sin(this.aimAngle) * this.staffLength;
        this.vel.x -= Math.cos(this.aimAngle) * 40;
        this.vel.y -= Math.sin(this.aimAngle) * 40;
        
        if (this.equipment.isThunderStaff) {
             let closestEnemy = null;
             let closestDistSq = Infinity;
             for (const enemy of game.enemies) {
                 if (enemy.isDead) continue;
                 const distSq = enemy.pos.sub(new Vec2(game.inputHandler.mousePos.x, game.inputHandler.mousePos.y)).magSq();
                 if (distSq < closestDistSq) {
                     closestDistSq = distSq;
                     closestEnemy = enemy;
                 }
             }
             const damage = this.stats.attackDamage * 3;
             game.effects.push(new LightningBolt(closestEnemy, damage));
             return;
        }

        const createProjectile = (angleOffset = 0) => {
            const p = new Projectile(staffTipX, staffTipY, 3, this.aimAngle + angleOffset, 'player');
            let damage = this.stats.attackDamage;
            if (this.hp / this.stats.maxHp < 0.5 && this.stats.rageMultiplier) {
                damage *= (1 + (1 - (this.hp / this.stats.maxHp)) * this.stats.rageMultiplier);
            }
            p.damage = damage;
            p.speed = this.stats.projectileSpeed;
            p.hitsLeft = this.stats.projectileHits;
            
            if (this.equipment.shootsHoming) p.isHoming = true;
            if (this.equipment.isExplosive) p.isExplosive = true;
            if (this.equipment.isRainbow) {
                const effects = ['homing', 'explosive', 'piercing'];
                const randomEffect = effects[Math.floor(Math.random() * effects.length)];
                if (randomEffect === 'homing') p.isHoming = true;
                if (randomEffect === 'explosive') p.isExplosive = true;
                if (randomEffect === 'piercing') p.hitsLeft = 999;
                p.color = PARTICLE_PALETTE[Math.floor(Math.random() * PARTICLE_PALETTE.length)];
            }

            game.projectiles.push(p);
        }

        if (this.equipment.isTrident) {
            createProjectile(-0.2);
            createProjectile(0);
            createProjectile(0.2);
        } else {
            createProjectile();
        }
    }
    
    takeDamage(amount, sourceEnemy = null) {
        if (this.isDead || this.invulnTimer > 0) return;
        
        const finalDamage = Math.max(1, amount * (1 - this.stats.defense));
        this.hp -= finalDamage;
        this.hitFlashTimer = 0.2;
        this.invulnTimer = this.stats.invulnOnHitDuration;

        game.triggerScreenShake(8, 0.2);
        game.effects.push(new FloatingText(Math.round(finalDamage), this.pos.x, this.pos.y, GLYPH_COLOR_DANGER, 20));
        
        if (sourceEnemy) {
            const knockbackDir = this.pos.sub(sourceEnemy.pos).normalize();
            this.vel = this.vel.add(knockbackDir.scale(BASE_KNOCKBACK_FORCE * 1.5));
        }
        
        if (this.hp <= 0) {
            if (this.revives > 0) {
                this.revives--;
                this.hp = this.stats.maxHp / 2;
                this.invulnTimer = 3.0;
                game.enemies.forEach(e => e.isDead = true);
                game.triggerFlash(0.5, UI_ACCENT_COLOR);
            } else {
                 this.hp = 0; this.isDead = true; game.endGame(); 
            }
        }
    }

    onHit(enemy, damageDealt) {
        if (this.stats.lifeSteal > 0) {
            this.heal(damageDealt * this.stats.lifeSteal);
        }
        if (this.stats.bleedChance > 0 && Math.random() < this.stats.bleedChance) {
             enemy.applyStatusEffect(new BleedStatus(this.stats.bleedDamage, 3));
        }
        if (this.stats.slowOnHit > 0) {
            enemy.slowMultiplier = Math.max(0.2, enemy.slowMultiplier - this.stats.slowOnHit);
        }
    }
    
    onKill(enemy) {
        this.gainXp(enemy.xpValue);
        if (Math.random() < this.stats.soulDropChance) { 
            this.runSouls++;
        }
        if (this.stats.healingOrbChance > 0 && Math.random() < this.stats.healingOrbChance) {
        }
        if (this.stats.fragmentationProjectiles > 0) {
            for (let i = 0; i < this.stats.fragmentationProjectiles; i++) {
                const p = new Projectile(enemy.pos.x, enemy.pos.y, 2, Math.random() * Math.PI * 2, 'player');
                p.damage = 3;
                p.life = 0.5;
                game.projectiles.push(p);
            }
        }
    }

    gainXp(amount) {
        if (this.isDead) return;
        this.xp += amount;
        while (this.xp >= this.xpToNextLevel()) {
            this.xp -= this.xpToNextLevel();
            this.level++;
            game.triggerLevelUp();
        }
    }
    
    heal(amount) {
        if (this.isDead) return;
        this.hp = Math.min(this.stats.maxHp, this.hp + amount);
        game.particleEngine.createHealEffect(this.pos.x, this.pos.y);
    }
}

class BleedStatus {
    constructor(dps, duration) {
        this.id = 'bleed';
        this.dps = dps;
        this.duration = duration;
        this.timer = 0;
        this.isFinished = false;
    }
    update(dt, enemy) {
        this.duration -= dt;
        if(this.duration <= 0) {
            this.isFinished = true;
            return;
        }
        this.timer -= dt;
        if(this.timer <= 0) {
            this.timer = 1.0;
            enemy.hp -= this.dps;
            if(enemy.hp <= 0) enemy.isDead = true;
            game.effects.push(new FloatingText(this.dps, enemy.pos.x, enemy.pos.y, '#cf2a27', 12));
        }
    }
    refresh(newEffect) {
        this.duration = Math.max(this.duration, newEffect.duration);
        this.dps = Math.max(this.dps, newEffect.dps);
    }
}

class ParticleEngine {
    constructor(game) { this.game = game; }
    create(count, x, y, options) {
        for (let i = 0; i < count; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * (options.maxSpeed - options.minSpeed) + options.minSpeed;
            const life = Math.random() * (options.maxLife - options.minLife) + options.minLife;
            const size = Math.random() * (options.maxSize - options.minSize) + options.minSize;
            const color = options.colors[Math.floor(Math.random() * options.colors.length)];
            const gravity = options.gravityEffect !== undefined ? options.gravityEffect : 0.5;
            this.game.particles.push(new Particle(x, y, Math.cos(angle) * speed, Math.sin(angle) * speed, life, color, size, gravity));
        }
    }
    createProjectileImpact(x, y, color) { this.create(Math.floor(Math.random()*5 + 5), x, y, { minSpeed: 20, maxSpeed: 100, minLife: 0.2, maxLife: 0.5, minSize: 1, maxSize: 3, colors: [color], gravityEffect: 0.3 }); }
    createEnemyDeathExplosion(x, y, sizeMultiplier = 1) { this.create(Math.floor(Math.random()*20 + 30) * sizeMultiplier, x, y, { minSpeed: 50, maxSpeed: 250, minLife: 0.5, maxLife: 1.2, minSize: 1, maxSize: 4, colors: PARTICLE_PALETTE, gravityEffect: 0.2 }); }
    createJumpDust(x, y) { this.create(10, x, y, { minSpeed: 10, maxSpeed: 50, minLife: 0.3, maxLife: 0.6, minSize: 1, maxSize: 3, colors: ['#ccc', '#eee'], gravityEffect: -0.1 }); }
    createHealEffect(x, y) { this.create(15, x, y, { minSpeed: 20, maxSpeed: 60, minLife: 0.4, maxLife: 0.8, minSize: 2, maxSize: 4, colors: ['#00ff00', '#90ee90'], gravityEffect: -0.5 }); }
    createTrail(x, y, color) { this.create(1, x, y, { minSpeed: 0, maxSpeed: 10, minLife: 0.1, maxLife: 0.3, minSize: 1, maxSize: 2, colors: [color], gravityEffect: 0 }); }
    createSpawnEffect(x, y) { this.create(25, x, y, { minSpeed: 40, maxSpeed: 150, minLife: 0.4, maxLife: 0.8, minSize: 1, maxSize: 3, colors: [GLYPH_COLOR_DANGER, '#8B0000'], gravityEffect: 0.1 }); }
}

class UpgradeManager {
    constructor(player, game) {
        this.player = player;
        this.game = game;
        this.masterList = FULL_UPGRADE_LIST;
        this.availableUpgrades = [];
    }
    init() { 
        this.availableUpgrades = [...this.masterList];
        this.player.stats.fragmentationProjectiles = 0;
        this.player.stats.frictionProjectiles = 0;
        this.player.stats.rageMultiplier = 0;
        this.player.stats.healingOrbChance = 0;
        this.player.stats.slowOnHit = 0;
        this.player.stats.bleedChance = 0;
        this.player.stats.bleedDamage = 0;
        this.player.lightningGenerators = [];
        this.player.stats.isShrunk = 1.0;
    }

    getUpgradeChoices(count = 3) {
        const choices = [];
        const numChoicesToPick = count + (this.player.stats.bonusUpgradeChoices || 0);

        const validPools = {
            common: [],
            uncommon: [],
            epic: [],
            ascension: []
        };
        
        if (this.player.equipment.forceUncommon) {
            const uncommonUpgrades = this.availableUpgrades.filter(upg => upg.rarity === 'uncommon' && (this.player.activeUpgrades.get(upg.id) || 0) < upg.maxStacks);
            while (choices.length < numChoicesToPick && uncommonUpgrades.length > 0) {
                 const choiceIndex = Math.floor(Math.random() * uncommonUpgrades.length);
                 choices.push(uncommonUpgrades.splice(choiceIndex, 1)[0]);
            }
            return choices;
        }

        for (const upg of this.availableUpgrades) {
            const currentStacks = this.player.activeUpgrades.get(upg.id) || 0;
            if (currentStacks >= upg.maxStacks) continue;
            let prereqsMet = true;
            if (upg.rarity === 'ascension') {
                switch (upg.id) {
                    case 'streamer': if ((this.player.activeUpgrades.get('resonance') || 0) < 8) prereqsMet = false; break;
                    case 'vampire': if ((this.player.activeUpgrades.get('leech') || 0) < 12) prereqsMet = false; break;
                    case 'colossus': if ((this.player.activeUpgrades.get('growth') || 0) < 15) prereqsMet = false; break;
                    case 'god_of_thunder': if ((this.player.activeUpgrades.get('thunderbolt') || 0) < 10) prereqsMet = false; break;
                    case 'flying_sorcerer': if ((this.player.activeUpgrades.get('gush') || 0) < 5) prereqsMet = false; break;
                }
            }
            if (prereqsMet) {
                validPools[upg.rarity].push(upg);
            }
        }

        const weights = { common: 65, uncommon: 25, epic: 8, ascension: 2 };
        const luckFactor = 1 + ((this.player.stats.luck || 0) / 100);
        weights.uncommon *= luckFactor;
        weights.epic *= luckFactor;
        weights.ascension *= luckFactor;
        
        const rarityOrder = ['ascension', 'epic', 'uncommon', 'common'];

        while (choices.length < numChoicesToPick && rarityOrder.some(r => validPools[r].length > 0)) {
            const totalWeight = Object.values(weights).reduce((a, b) => a + b, 0);
            let rand = Math.random() * totalWeight;

            let chosenRarity = 'common';
            for (const rarity in weights) {
                if (rand < weights[rarity]) {
                    chosenRarity = rarity;
                    break;
                }
                rand -= weights[rarity];
            }

            let chosenPool = null;
            for (let i = rarityOrder.indexOf(chosenRarity); i < rarityOrder.length; i++) {
                const currentRarity = rarityOrder[i];
                if (validPools[currentRarity].length > 0) {
                    chosenPool = validPools[currentRarity];
                    break;
                }
            }

            if (!chosenPool) {
                 for (const rarity of rarityOrder) {
                     if (validPools[rarity].length > 0) {
                         chosenPool = validPools[rarity];
                         break;
                     }
                 }
            }

            if (chosenPool) {
                const choiceIndex = Math.floor(Math.random() * chosenPool.length);
                const choice = chosenPool[choiceIndex];
                choices.push(choice);
                chosenPool.splice(choiceIndex, 1);
            } else {
                break;
            }
        }
        return choices;
    }

    applyUpgrade(upgrade) {
        upgrade.apply(this.player, this.game);
        const currentStacks = (this.player.activeUpgrades.get(upgrade.id) || 0) + 1;
        this.player.activeUpgrades.set(upgrade.id, currentStacks);
        if (currentStacks === 1) { 
            this.game.uiManager.addUpgradeIcon(upgrade);
        }
    }
}

const GLYPH_DATA = { 
    PLAYER: [{ x: 0, y: -22 }, { x: 15, y: -7 }, { x: 12, y: 22 }, { x: -12, y: 22 }, { x: -15, y: -7 }], 
    ENEMY_PEON: [{x:0,y:-10},{x:10,y:0},{x:0,y:10},{x:-10,y:0}], 
    ENEMY_KING: [{x:0,y:-15},{x:5,y:-20},{x:10,y:-15},{x:15,y:0},{x:10,y:15}, {x:0,y:20},{x:-10,y:15},{x:-15,y:0},{x:-10,y:-15},{x:-5,y:-20}], 
    WISP: [{x:0,y:-8},{x:8,y:8},{x:-8,y:8}], 
    GENERIC_PLUS: [{x:-10,y:-2},{x:10,y:-2},{x:10,y:2},{x:-10,y:2},{x:-10,y:-2},{x:-2,y:-10},{x:2,y:-10},{x:2,y:10},{x:-2,y:10}],
    GENERIC_ARROW_UP: [{x:0,y:-10},{x:10,y:0},{x:5,y:0},{x:5,y:10},{x:-5,y:10},{x:-5,y:0},{x:-10,y:0}],
    GENERIC_SHIELD: [{x:0,y:-12},{x:12,y:-6},{x:12,y:6},{x:0,y:12},{x:-12,y:6},{x:-12,y:-6}],
    GENERIC_BOLT: [{x:5,y:-12},{x:-5,y:0},{x:5,y:0},{x:-5,y:12}],
    GENERIC_FRAGMENT: [{x:-5,y:-5},{x:0,y:-10},{x:5,y:-5},{x:10,y:0},{x:5,y:5},{x:0,y:10},{x:-5,y:5},{x:-10,y:0}],
    GENERIC_PERSON: [{x:0,y:-10},{x:5,y:-5},{x:-5,y:-5},{x:0,y:-10},{x:0,y:0},{x:8,y:10},{x:-8,y:10},{x:0,y:0}],
    GENERIC_HAT: [{x:-12,y:0},{x:12,y:0},{x:0,y:-15}],
    GENERIC_TRIDENT: [{x:0,y:10},{x:0,y:-10},{x:-8,y:-2},{x:0,y:-10},{x:8,y:-2}]
};

const ENEMY_DATA = { 
    peon: { hp: 8, damage: 5, speed: 80, xp: 10, width: 20, height: 20, glyph: GLYPH_DATA.ENEMY_PEON, threatCost: 1 }, 
    king: { hp: 80, damage: 15, speed: 50, xp: 50, width: 30, height: 40, glyph: GLYPH_DATA.ENEMY_KING, threatCost: 5 }
};

const STAVES_DATA = {
    wizards_staff: { name: "Wizard's Staff", description: 'Shoots a projectile in a straight line.', glyph: GLYPH_DATA.GENERIC_BOLT, cost: 0, apply: (p) => {} },
    emerald_staff: { name: 'Emerald Staff', description: 'Shoots homing projectiles and has higher attack speed but deals half damage.', glyph: GLYPH_DATA.GENERIC_FRAGMENT, cost: 50, apply: (p) => { p.equipment.shootsHoming = true; p.stats.attackDamage *= 0.5; p.stats.attackSpeed *= 1.3; } },
    trident: { name: 'Trident', description: 'Shoots 3 projectiles in an angle.', glyph: GLYPH_DATA.GENERIC_TRIDENT, cost: 75, apply: (p) => { p.equipment.isTrident = true; } },
    boomstaff: { name: 'Boomstaff', description: 'Shoots explosive projectiles.', glyph: GLYPH_DATA.GENERIC_FRAGMENT, cost: 100, apply: (p) => { p.equipment.isExplosive = true; } },
    thunder_staff: { name: 'Thunder Staff', description: 'Calls a thunderbolt from above on the nearest enemy to the cursor.', glyph: GLYPH_DATA.GENERIC_BOLT, cost: 150, apply: (p) => { p.equipment.isThunderStaff = true; } },
    frozen_tip: { name: 'Frozen Tip', description: 'Projectiles pierce through all enemies.', glyph: GLYPH_DATA.GENERIC_ARROW_UP, cost: 120, apply: (p) => { p.stats.projectileHits = 999; } },
    rainbow_staff: { name: 'Rainbow Staff', description: 'Shoots projectiles with random properties (homing, explosive, or piercing).', glyph: GLYPH_DATA.GENERIC_PLUS, cost: 200, apply: (p) => { p.equipment.isRainbow = true; } },
};

const ROBES_DATA = {
    wizards_hat: { name: "Wizard's Hat", description: 'A cool pointy hat. No special effects.', glyph: GLYPH_DATA.GENERIC_HAT, cost: 0, apply: (p) => {} },
    helmet: { name: 'Helmet', description: 'Defense +15%. Move Speed -15%.', glyph: GLYPH_DATA.GENERIC_SHIELD, cost: 80, apply: (p) => { p.stats.defense += 0.15; p.stats.moveSpeedMultiplier *= 0.85; } },
    propeller_beanie: { name: 'Propeller Beanie', description: 'Gain a double jump. Cannot control jump height.', glyph: GLYPH_DATA.GENERIC_ARROW_UP, cost: 100, apply: (p) => { p.equipment.hasPropellerBeanie = true; p.maxJumps = 2; } },
    uncommon_hat: { name: 'Uncommon Hat', description: 'You will only be offered Uncommon upgrades upon level-up.', glyph: GLYPH_DATA.GENERIC_PLUS, cost: 250, apply: (p) => { p.equipment.forceUncommon = true; } },
};

const FULL_UPGRADE_LIST = [
    { id: 'catalyst', name: 'Catalyst', rarity: 'common', description: 'Projectile Damage +2', maxStacks: 20, glyph: GLYPH_DATA.GENERIC_PLUS, apply: (p) => { p.stats.attackDamage += 2; },
      generateDescription: (p) => `Projectile Damage +2<br>(Current: ${p.stats.attackDamage})` },
    { id: 'eyesight', name: 'Eyesight', rarity: 'common', description: 'Critical Chance +5%', maxStacks: 6, glyph: GLYPH_DATA.GENERIC_PLUS, apply: (p) => { p.stats.critChance += 0.05; },
      generateDescription: (p) => `Critical Chance +5%<br>(Current: ${Math.round(p.stats.critChance*100)}%)` },
    { id: 'growth', name: 'Growth', rarity: 'common', description: 'Max. HP +10', maxStacks: 15, glyph: GLYPH_DATA.GENERIC_PLUS, apply: (p) => { p.stats.maxHp += 10; p.heal(10); },
      generateDescription: (p) => `Max. HP +10<br>(Current: ${p.stats.maxHp})` },
    { id: 'impulse', name: 'Impulse', rarity: 'common', description: 'Jump Height +30%', maxStacks: 5, glyph: GLYPH_DATA.GENERIC_ARROW_UP, apply: (p) => { p.stats.jumpHeightMultiplier += 0.3; } },
    { id: 'renew', name: 'Renew', rarity: 'common', description: 'Heal to Max. HP', maxStacks: 5, glyph: GLYPH_DATA.GENERIC_PLUS, apply: (p) => { p.heal(p.stats.maxHp); } },
    { id: 'resist', name: 'Resist', rarity: 'common', description: 'Defense +4%', maxStacks: 6, glyph: GLYPH_DATA.GENERIC_SHIELD, apply: (p) => { p.stats.defense += 0.04; },
      generateDescription: (p) => `Defense +4%<br>(Current: ${Math.round(p.stats.defense*100)}%)` },
    { id: 'resonance', name: 'Resonance', rarity: 'common', description: 'Atk Speed +12%', maxStacks: 8, glyph: GLYPH_DATA.GENERIC_PLUS, apply: (p) => { p.stats.attackSpeed += 0.12 * BASE_ATTACK_SPEED; } },
    { id: 'souls', name: 'Souls', rarity: 'common', description: 'Chance to drop soul orb +1%', maxStacks: 6, glyph: GLYPH_DATA.GENERIC_PLUS, apply: (p) => { p.stats.soulDropChance += 0.01; } },
    { id: 'stability', name: 'Stability', rarity: 'common', description: 'Projectile takes +1 hit before exploding', maxStacks: 5, glyph: GLYPH_DATA.GENERIC_SHIELD, apply: (p) => { p.stats.projectileHits += 1; } },
    { id: 'swift', name: 'Swift', rarity: 'common', description: 'Movement Speed +20%', maxStacks: 8, glyph: GLYPH_DATA.GENERIC_ARROW_UP, apply: (p) => { p.stats.moveSpeedMultiplier += 0.2; } },
    { id: 'catalyst+', name: 'Catalyst+', rarity: 'uncommon', description: 'Projectile Damage +4', maxStacks: 1, glyph: GLYPH_DATA.GENERIC_PLUS, apply: (p) => { p.stats.attackDamage += 4; } },
    { id: 'charge', name: 'Charge', rarity: 'uncommon', description: 'Projectile Size +20%', maxStacks: 5, glyph: GLYPH_DATA.GENERIC_PLUS, apply: (p) => { p.stats.projectileSize += 0.2; } },
    { id: 'cloak', name: 'Cloak', rarity: 'uncommon', description: 'Invulnerability after taking damage +0.1s duration', maxStacks: 4, glyph: GLYPH_DATA.GENERIC_SHIELD, apply: (p) => { p.stats.invulnOnHitDuration += 0.1; } },
    { id: 'fragmentation', name: 'Fragmentation', rarity: 'uncommon', description: 'When killed, enemies release 2 weaker projectiles', maxStacks: 10, glyph: GLYPH_DATA.GENERIC_FRAGMENT, apply: (p) => { p.stats.fragmentationProjectiles += 2; } },
    { id: 'friction', name: 'Friction', rarity: 'uncommon', description: 'For every meter you run, 1 explosive projectile is launched upwards', maxStacks: 10, glyph: GLYPH_DATA.GENERIC_ARROW_UP, apply: (p) => { p.stats.frictionProjectiles += 1; } },
    { id: 'growth+', name: 'Growth+', rarity: 'uncommon', description: 'Max. HP +20', maxStacks: 1, glyph: GLYPH_DATA.GENERIC_PLUS, apply: (p) => { p.stats.maxHp += 20; p.heal(20); } },
    { id: 'gush', name: 'Gush', rarity: 'uncommon', description: 'Adds +1 Jump', maxStacks: 5, glyph: GLYPH_DATA.GENERIC_ARROW_UP, apply: (p) => { p.maxJumps += 1; } },
    { id: 'leech', name: 'Leech', rarity: 'uncommon', description: 'Life Steal of 3% Damage', maxStacks: 12, glyph: GLYPH_DATA.GENERIC_PLUS, apply: (p) => { p.stats.lifeSteal += 0.03; } },
    { id: 'luck', name: 'Luck', rarity: 'uncommon', description: 'Bigger chance to roll uncommon items', maxStacks: 5, glyph: GLYPH_DATA.GENERIC_PLUS, apply: (p) => { p.stats.luck += 10; } },
    { id: 'orb', name: 'Orb', rarity: 'uncommon', description: 'Dead enemies have 5% chance to drop a healing orb', maxStacks: 5, glyph: GLYPH_DATA.GENERIC_PLUS, apply: (p) => { p.stats.healingOrbChance += 0.05; } },
    { id: 'precision', name: 'Precision', rarity: 'uncommon', description: 'Criticals deal +50% damage', maxStacks: 5, glyph: GLYPH_DATA.GENERIC_PLUS, apply: (p) => { p.stats.critDamageMultiplier += 0.5; } },
    { id: 'rage', name: 'Rage', rarity: 'uncommon', description: 'If under 50% HP, raises your damage (up to 50%)', maxStacks: 5, glyph: GLYPH_DATA.GENERIC_FRAGMENT, apply: (p) => { p.stats.rageMultiplier += 0.5; } },
    { id: 'resonance+', name: 'Resonance+', rarity: 'uncommon', description: 'Attack Speed +24%', maxStacks: 1, glyph: GLYPH_DATA.GENERIC_PLUS, apply: (p) => { p.stats.attackSpeed += 0.24 * BASE_ATTACK_SPEED; } },
    { id: 'shrink', name: 'Shrink', rarity: 'uncommon', description: 'Makes you 10% smaller', maxStacks: 5, glyph: GLYPH_DATA.GENERIC_PERSON, apply: (p) => { p.stats.isShrunk -= 0.1; } },
    { id: 'swift+', name: 'Swift+', rarity: 'uncommon', description: 'Movement Speed +40%', maxStacks: 1, glyph: GLYPH_DATA.GENERIC_ARROW_UP, apply: (p) => { p.stats.moveSpeedMultiplier += 0.4; } },
    { id: 'thunderbolt', name: 'Thunderbolt', rarity: 'uncommon', description: 'Calls 2 thunderbolts every few seconds', maxStacks: 10, glyph: GLYPH_DATA.GENERIC_BOLT, apply: (p, g) => { g.addLightningGenerator(2, 5); } },
    { id: 'appraisal', name: 'Appraisal', rarity: 'epic', description: '+1 item choice from now on', maxStacks: 4, glyph: GLYPH_DATA.GENERIC_PLUS, apply: (p) => { p.stats.bonusUpgradeChoices += 1; } },
    { id: 'cold', name: 'Cold', rarity: 'epic', description: 'Enemies get 1% slower every time they take damage (up to 80%)', maxStacks: 3, glyph: GLYPH_DATA.GENERIC_BOLT, apply: (p) => { p.stats.slowOnHit = (p.stats.slowOnHit || 0) + 0.01; } },
    { id: 'fragmentation+', name: 'Fragmentation+', rarity: 'epic', description: 'Enemies release 6 weaker projectiles on death', maxStacks: 1, glyph: GLYPH_DATA.GENERIC_FRAGMENT, apply: (p) => { p.stats.fragmentationProjectiles += 6; } },
    { id: 'growth++', name: 'Growth++', rarity: 'epic', description: 'Max. HP +40', maxStacks: 1, glyph: GLYPH_DATA.GENERIC_PLUS, apply: (p) => { p.stats.maxHp += 40; p.heal(40); } },
    { id: 'immortal', name: 'Immortal', rarity: 'epic', description: '+1 Revive (kill all enemies when reviving)', maxStacks: 1, glyph: GLYPH_DATA.GENERIC_PLUS, apply: (p) => { p.revives += 1; } },
    { id: 'leech+', name: 'Leech+', rarity: 'epic', description: 'Life Steal of 9% Damage', maxStacks: 1, glyph: GLYPH_DATA.GENERIC_PLUS, apply: (p) => { p.stats.lifeSteal += 0.09; } },
    { id: 'overheat', name: 'Overheat', rarity: 'epic', description: 'Your body deals 40 damage on contact', maxStacks: 3, glyph: GLYPH_DATA.GENERIC_FRAGMENT, apply: (p) => { p.stats.bodyDamage += 40; } },
    { id: 'thunderbolt+', name: 'Thunderbolt+', rarity: 'epic', description: 'Calls 6 thunderbolts every few seconds', maxStacks: 1, glyph: GLYPH_DATA.GENERIC_BOLT, apply: (p, g) => { g.addLightningGenerator(6, 5); } },
    { id: 'will-o-wisp', name: 'Will-O-Wisp', rarity: 'epic', description: 'Summons a wisp that inherits half your attack damage and speed', maxStacks: 4, glyph: GLYPH_DATA.WISP, apply: (p) => { p.wisps.push(new WillOWisp(p)); } },
    { id: 'wound', name: 'Wound', rarity: 'epic', description: 'Dealing damage applies bleeding to the enemy', maxStacks: 3, glyph: GLYPH_DATA.GENERIC_FRAGMENT, apply: (p) => { p.stats.bleedChance = 1; p.stats.bleedDamage = (p.stats.bleedDamage || 0) + 2; } },
    { id: 'streamer', name: 'Streamer', rarity: 'ascension', description: 'Shoots a continuous beam from your staff. (Get 8 Resonance)', maxStacks: 1, glyph: GLYPH_DATA.GENERIC_BOLT, apply: (p, g) => { p.hasStreamer = true; for(let i=0; i<8; i++) g.upgradeManager.masterList.find(u=>u.id==='resonance').apply(p,g); } },
    { id: 'vampire', name: 'Vampire', rarity: 'ascension', description: 'Half of all your damage returns as HP. (Get 12 Leech)', maxStacks: 1, glyph: GLYPH_DATA.GENERIC_PLUS, apply: (p, g) => { p.stats.lifeSteal = 0.5; for(let i=0; i<12; i++) g.upgradeManager.masterList.find(u=>u.id==='leech').apply(p,g); } },
    { id: 'colossus', name: 'Colossus', rarity: 'ascension', description: 'Your HP and size are doubled. (Get 15 Growth)', maxStacks: 1, glyph: GLYPH_DATA.GENERIC_PERSON, apply: (p,g) => { p.stats.maxHp *= 2; p.heal(p.stats.maxHp); p.stats.isShrunk = 2.0; for(let i=0; i<15; i++) g.upgradeManager.masterList.find(u=>u.id==='growth').apply(p,g); } },
    { id: 'god_of_thunder', name: 'God of Thunder', rarity: 'ascension', description: 'Your thunderbolts deal 3x more damage. (Get 10 Thunderbolt)', maxStacks: 1, glyph: GLYPH_DATA.GENERIC_BOLT, apply: (p, g) => { p.lightningGenerators.forEach(lg => lg.damageMultiplier *= 3); for(let i=0; i<10; i++) g.upgradeManager.masterList.find(u=>u.id==='thunderbolt').apply(p,g); } },
    { id: 'flying_sorcerer', name: 'Flying Sorcerer', rarity: 'ascension', description: 'You can jump as much as you want. (Get 5 Gush)', maxStacks: 1, glyph: GLYPH_DATA.GENERIC_ARROW_UP, apply: (p,g) => { p.maxJumps = 999; for(let i=0; i<5; i++) g.upgradeManager.masterList.find(u=>u.id==='gush').apply(p,g); } },
];


class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.width = CANVAS_WIDTH;
        this.height = CANVAS_HEIGHT;
        this.canvas.width = this.width;
        this.canvas.height = this.height;
        this.gameState = GameState.MENU;
        this.lastTime = 0;
        this.deltaTime = 0;
        this.screenShake = { intensity: 0, duration: 0 };
        this.hitStopTimer = 0;
        this.flash = { alpha: 0, color: '#FFFFFF', duration: 0 };
        this.selectedEquipment = { staff: null, robe: null };
        this.pauseDebounce = false;
        
    }
    init() {
        this.inputHandler = new InputHandler();
        this.playerDataManager = new PlayerDataManager();
        this.playerDataManager.load();
        this.uiManager = new UIManager();
        this.renderer = new Renderer(this.canvas, this.ctx);
        this.player = new Player(this.width / 2, this.height / 2);
        this.upgradeManager = new UpgradeManager(this.player, this);
        this.particleEngine = new ParticleEngine(this);
        const W = this.width; const H = this.height;
        
        this.platforms = [ new Platform(-200, H - 40, W + 400) ];
        
        this.spawnPoints = [ 
            new Vec2(W * 0.5, -150),
            new Vec2(W * 0.1, -100),
            new Vec2(W * 0.9, -100),
            new Vec2(-100, -100),
            new Vec2(W + 100, -100)
        ];
        
        document.getElementById('restart-button').onclick = () => this.restart();
        
        document.getElementById('start-button').onclick = () => {
            this.uiManager.hideStartScreen();
            this.start();
        };

        document.getElementById('equipment-button').onclick = () => {
            this.uiManager.hideStartScreen();
            this.showEquipmentScreen();
        };

        document.getElementById('back-to-menu-button').onclick = () => {
            this.uiManager.hideEquipmentScreen();
            this.uiManager.showStartScreen();
            this.gameState = GameState.MENU;
        };
        
        document.getElementById('continue-button').onclick = () => this.togglePause();
        document.getElementById('menu-button').onclick = () => this.returnToMenu();

        this.reset();
        this.uiManager.showStartScreen();
    }
    
    reset() {
        this.player.init();
        
        if (!this.selectedEquipment.staff) this.selectedEquipment.staff = 'wizards_staff';
        if (!this.selectedEquipment.robe) this.selectedEquipment.robe = 'wizards_hat';
        STAVES_DATA[this.selectedEquipment.staff].apply(this.player);
        ROBES_DATA[this.selectedEquipment.robe].apply(this.player);

        this.upgradeManager.init();
        this.uiManager.upgradeTray.innerHTML = '';
        this.enemies = []; this.projectiles = []; this.particles = []; this.effects = [];
        this.gameTime = 0; this.kills = 0;
        
        this.currentWave = 0;
        this.waveState = 'INTERMISSION';
        this.intermissionTimer = 3.0;

        this.spawnPool = ['peon'];
        this.uiManager.hideGameOver();
        this.uiManager.update(this.player, this);
    }

    showEquipmentScreen() {
        this.gameState = GameState.EQUIPMENT_SELECTION;
        this.uiManager.equipmentTotalSouls.textContent = `Total Souls: ${this.playerDataManager.data.totalSouls}`;
        const stavesContainer = document.getElementById('staves-selection');
        const robesContainer = document.getElementById('robes-selection');
        stavesContainer.innerHTML = '';
        robesContainer.innerHTML = '';

        const createCard = (itemData, id, type) => {
            const card = document.createElement('div');
            card.className = 'equipment-card';
            card.id = `${type}-card-${id}`;

            const isUnlocked = this.playerDataManager.isUnlocked(type, id);

            let buttonHTML = '';
            if (isUnlocked) {
                card.onclick = () => this.selectEquipment(id, type);
            } else {
                card.classList.add('locked');
                const canAfford = this.playerDataManager.data.totalSouls >= itemData.cost;
                buttonHTML = `<button class="general-button buy-button" ${canAfford ? '' : 'disabled'} onclick="game.buyEquipment('${type}', '${id}')">Buy (${itemData.cost})</button>`;
            }

            card.innerHTML = `
                <div class="equipment-card-header">
                    <canvas class="equipment-glyph-canvas" id="equip-glyph-${id}" width="50" height="50"></canvas>
                    <div class="equipment-info">
                        <h3>${itemData.name}</h3>
                        <p>${itemData.description}</p>
                    </div>
                </div>
                ${buttonHTML}
            `;
            
            if (type === 'staves') stavesContainer.appendChild(card);
            else robesContainer.appendChild(card);

            const canvas = document.getElementById(`equip-glyph-${id}`);
            const ctx = canvas.getContext('2d');
            const renderer = new Renderer(canvas, ctx);
            renderer.drawGlyph(ctx, itemData.glyph, 25, 25, 0, 2, { color: UI_TEXT_COLOR, shadowBlur: 0 });
        };

        for (const id in STAVES_DATA) createCard(STAVES_DATA[id], id, 'staves');
        for (const id in ROBES_DATA) createCard(ROBES_DATA[id], id, 'robes');
        
        if (this.selectedEquipment.staff) document.getElementById(`staves-card-${this.selectedEquipment.staff}`)?.classList.add('selected');
        if (this.selectedEquipment.robe) document.getElementById(`robes-card-${this.selectedEquipment.robe}`)?.classList.add('selected');

        this.uiManager.showEquipmentScreen();
    }
    
    buyEquipment(type, id) {
        event.stopPropagation();
        const itemData = type === 'staves' ? STAVES_DATA[id] : ROBES_DATA[id];
        if (this.playerDataManager.spendSouls(itemData.cost)) {
            this.playerDataManager.unlockItem(type, id);
            this.showEquipmentScreen();
        }
    }

    selectEquipment(id, type) {
        const containerId = type === 'staves' ? 'staves-selection' : 'robes-selection';
        const allCards = document.getElementById(containerId).querySelectorAll('.equipment-card');
        allCards.forEach(c => c.classList.remove('selected'));

        document.getElementById(`${type}-card-${id}`).classList.add('selected');

        if (type === 'staves') {
            this.selectedEquipment.staff = id;
        } else {
            this.selectedEquipment.robe = id;
        }
    }
    start() { 
        this.reset(); 
        this.uiManager.hideStartScreen(); 
        this.gameState = GameState.PLAYING; 
    }
    restart() { this.reset(); this.gameState = GameState.PLAYING; }
    gameLoop(timestamp) {
        if (!this.lastTime) this.lastTime = timestamp;
        this.deltaTime = (timestamp - this.lastTime) / 1000;
        this.lastTime = timestamp;

        this.handlePauseInput();

        if (this.hitStopTimer > 0) { 
            this.hitStopTimer -= this.deltaTime; 
        } else { 
            if (this.gameState === GameState.PLAYING) { 
                this.update(); 
            } 
        }
        this.draw();
        requestAnimationFrame(this.gameLoop.bind(this));
    }
    update() {
        const dt = this.deltaTime;
        this.gameTime += dt;
        if (this.flash.alpha > 0) { this.flash.alpha -= dt / this.flash.duration; }

        if (this.waveState === 'FIGHTING' && this.enemies.length === 0) {
            this.waveState = 'INTERMISSION';
            this.intermissionTimer = 5.0;
        } else if (this.waveState === 'INTERMISSION') {
            this.intermissionTimer -= dt;
            if (this.intermissionTimer <= 0) {
                this.startNextWave();
            }
        }
        
        if (this.gameTime > 60 && !this.spawnPool.includes('king')) { this.spawnPool.push('king'); }

        this.player.update(dt, this.platforms, this.inputHandler, this);
        
        this.enemies.forEach(e => e.update(dt, this.player, this.platforms));
        this.projectiles.forEach(p => p.update(dt));
        this.particles.forEach(p => p.update(dt));
        this.effects.forEach(e => e.update(dt, this.enemies, this));
        this.player.lightningGenerators.forEach(lg => lg.update(dt, this.enemies, this));

        const deathY = this.height + 100;
        if (!this.player.isDead && this.player.pos.y > deathY) { this.player.takeDamage(9999); }
        this.enemies.forEach(enemy => { if (enemy.pos.y > deathY) enemy.isDead = true; });
        this.handleCollisions();
        this.enemies = this.enemies.filter(e => !e.isDead);
        this.projectiles = this.projectiles.filter(p => !p.isDead);
        this.particles = this.particles.filter(p => p.life > 0);
        this.effects = this.effects.filter(e => e.life === undefined || e.life > 0);
    }

    startNextWave() {
        this.currentWave++;
        this.waveState = 'FIGHTING';
        this.uiManager.showWaveAnnouncer(this.currentWave);

        let threatBudget = 5 + this.currentWave * 3;
        const waveComposition = [];

        while (threatBudget > 0) {
            const availableEnemies = this.spawnPool.filter(type => ENEMY_DATA[type].threatCost <= threatBudget);
            if (availableEnemies.length === 0) break;

            const enemyType = availableEnemies[Math.floor(Math.random() * availableEnemies.length)];
            waveComposition.push(enemyType);
            threatBudget -= ENEMY_DATA[enemyType].threatCost;
        }

        waveComposition.forEach(type => {
            const spawnPoint = this.spawnPoints[Math.floor(Math.random() * this.spawnPoints.length)];
            const spawnOffset = new Vec2((Math.random() - 0.5) * 50, (Math.random() - 0.5) * 50);
            const spawnPos = spawnPoint.add(spawnOffset);
            const newEnemy = new Enemy(spawnPos.x, spawnPos.y, type);
            this.enemies.push(newEnemy);
            this.particleEngine.createSpawnEffect(newEnemy.pos.x, newEnemy.pos.y);
        });
    }

    draw() {
        this.ctx.save();
        if (this.screenShake.duration > 0) {
            this.screenShake.duration -= this.deltaTime;
            this.ctx.translate((Math.random() - 0.5) * this.screenShake.intensity, (Math.random() - 0.5) * this.screenShake.intensity);
        }
        
        this.renderer.clear();
        
        if (!this.player.isDead) this.player.draw();

        this.platforms.forEach(p => p.draw(this.renderer));
        this.renderer.drawLightRays(this.player.pos);
        this.particles.forEach(p => p.draw(this.ctx));
        this.enemies.forEach(e => e.draw(this.renderer));
        this.projectiles.forEach(p => p.draw(this.ctx));
        this.effects.forEach(e => e.draw(this.ctx));
        if (!this.player.isDead) this.renderer.drawVignette(this.player.pos);
        
        if (this.flash.alpha > 0) {
            this.ctx.fillStyle = this.flash.color;
            this.ctx.globalAlpha = this.flash.alpha;
            this.ctx.fillRect(0, 0, this.width, this.height);
        }
        
        this.ctx.restore();
        
        if (this.gameState === GameState.PLAYING || this.gameState === GameState.GAME_OVER || this.gameState === GameState.PAUSED) {
             this.uiManager.update(this.player, this);
        }
    }
    handleCollisions() {
        for (const projectile of this.projectiles) {
            if (projectile.owner !== 'player' || projectile.isDead) continue;
            for (const enemy of this.enemies) {
                if(enemy.isDead) continue;
                if (projectile.pos.sub(enemy.pos).magSq() < (projectile.collisionRadius + enemy.collisionRadius)**2) {
                    enemy.takeDamage(projectile.damage, { knockbackDir: projectile.vel.normalize(), knockbackForce: projectile.knockbackForce });
                    this.particleEngine.createProjectileImpact(projectile.pos.x, projectile.pos.y, projectile.color);
                    projectile.hitsLeft--;
                    if(projectile.hitsLeft <= 0) {
                        projectile.isDead = true;
                        break;
                    }
                }
            }
        }
        
        if (this.player.applyBeamDamageThisFrame) {
            const beamStart = this.player.pos;
            const beamDir = new Vec2(Math.cos(this.player.aimAngle), Math.sin(this.player.aimAngle));
            const damagePerTick = (this.player.stats.attackDamage * this.player.stats.attackSpeed) / BEAM_TICK_RATE;
            for (const enemy of this.enemies) {
                if(enemy.isDead) continue;
                const toEnemy = enemy.pos.sub(beamStart);
                const projection = toEnemy.x * beamDir.x + toEnemy.y * beamDir.y;
                if (projection > 0) {
                    const distSq = toEnemy.magSq() - projection * projection;
                    if (distSq < (enemy.collisionRadius + 10)**2) {
                        enemy.takeDamage(damagePerTick, {type: 'no-crit'});
                    }
                }
            }
        }

        for (const projectile of this.projectiles) {
            if (projectile.owner !== 'enemy' || projectile.isDead || this.player.isDead) continue;
            if (projectile.pos.sub(this.player.pos).magSq() < (projectile.collisionRadius + this.player.collisionRadius)**2) {
                this.player.takeDamage(projectile.damage);
                this.particleEngine.createProjectileImpact(projectile.pos.x, projectile.pos.y, projectile.color);
                projectile.isDead = true;
                break; 
            }
        }

        for (const enemy of this.enemies) {
            if(enemy.isDead) continue;
            if (!this.player.isDead && this.player.stats.bodyDamage > 0 && this.player.pos.sub(enemy.pos).magSq() < (this.player.collisionRadius + enemy.collisionRadius)**2) {
                enemy.takeDamage(this.player.stats.bodyDamage);
            }
        }
        
        for (let i = 0; i < this.enemies.length; i++) {
            for (let j = i + 1; j < this.enemies.length; j++) {
                const e1 = this.enemies[i]; const e2 = this.enemies[j];
                if(e1.isDead || e2.isDead) continue;
                const distVec = e1.pos.sub(e2.pos); const distSq = distVec.magSq();
                const totalRadius = e1.collisionRadius + e2.collisionRadius;
                if (distSq < totalRadius * totalRadius && distSq > 0) {
                    const separationVec = distVec.normalize().scale((totalRadius - Math.sqrt(distSq)) * 0.5);
                    e1.pos = e1.pos.add(separationVec);
                    e2.pos = e2.pos.sub(separationVec);
                }
            }
        }
    }
    
    spawnEnemy() {
    }
    
    triggerLevelUp() {
        this.gameState = GameState.UPGRADE_CHOICE;
        this.currentUpgradeChoices = this.upgradeManager.getUpgradeChoices(3);
        if (this.currentUpgradeChoices.length > 0) {
            this.uiManager.showUpgradeChoices(this.currentUpgradeChoices);
        } else {
            this.gameState = GameState.PLAYING;
        }
        this.renderer.lightRayOpacity = 0.3;
        this.triggerFlash(0.2, UI_ACCENT_COLOR);
        setTimeout(() => this.renderer.lightRayOpacity = 0.05, 500);
    }
    
    selectUpgrade(chosenUpgrade) {
        if (this.gameState !== GameState.UPGRADE_CHOICE) return;
        this.upgradeManager.applyUpgrade(chosenUpgrade);
        this.uiManager.hideUpgradeModal();
        this.gameState = GameState.PLAYING;
        this.currentUpgradeChoices = [];
    }
    endGame() {
        if (this.player.spriteElement) {
            this.player.spriteElement.style.display = 'none';
        }
        this.playerDataManager.data.totalSouls += this.player.runSouls;
        this.playerDataManager.save();

        this.gameState = GameState.GAME_OVER;
        this.triggerScreenShake(20, 0.5);
        this.triggerFlash(0.5, GLYPH_COLOR_DANGER);
        this.particleEngine.createEnemyDeathExplosion(this.player.pos.x, this.player.y, 3);
        this.uiManager.showGameOver(this);
    }
    
    handlePauseInput() {
        if (this.inputHandler.isDown('escape')) {
            if (!this.pauseDebounce) {
                this.togglePause();
                this.pauseDebounce = true;
            }
        } else {
            this.pauseDebounce = false;
        }
    }

    togglePause() {
        if (this.gameState === GameState.PLAYING) {
            this.gameState = GameState.PAUSED;
            this.uiManager.showPauseScreen();
        } else if (this.gameState === GameState.PAUSED) {
            this.gameState = GameState.PLAYING;
            this.uiManager.hidePauseScreen();
        }
    }
    
    returnToMenu() {
        this.uiManager.hidePauseScreen();
        this.uiManager.showStartScreen();
        this.gameState = GameState.MENU;
        this.selectedEquipment = { staff: null, robe: null };
    }

    addLightningGenerator(boltCount, interval) {
        let existing = this.player.lightningGenerators.find(lg => lg.interval === interval);
        if(existing) {
            existing.boltCount += boltCount;
        } else {
            const newLg = new LightningBoltGenerator(boltCount, interval);
            this.player.lightningGenerators.push(newLg);
        }
    }

    triggerScreenShake(intensity, duration) { this.screenShake.intensity = Math.max(this.screenShake.intensity, intensity); this.screenShake.duration = Math.max(this.screenShake.duration, duration); }
    triggerHitStop(duration) { this.hitStopTimer = Math.max(this.hitStopTimer, duration); }
    triggerFlash(duration, color = '#FFFFFF') { this.flash.alpha = 1.0; this.flash.duration = duration; this.flash.color = color; }
}

window.addEventListener('load', () => {
    window.game = new Game();
    game.init();
    game.gameLoop(0);
});
</script>

</body> 
</html> 
